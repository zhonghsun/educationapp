import Papa from 'papaparse';
import StudentEntry from 'containers/UsersPage/models/StudentEntry';

export enum CsvReadError {
  INVALID_FILE,
  INVALID_HEADER,
  INVALID_ROW,
}

export const csvHeaders = ['name', 'school_id', 'class'];

const internalCsvHeaders = [
  'name',
  'given_name',
  'family_name',
  'middle_name',
  'nickname',
  'preferred_username',
  'profile',
  'picture',
  'website',
  'email',
  'email_verified',
  'gender',
  'birthdate',
  'zoneinfo',
  'locale',
  'phone_number',
  'phone_number_verified',
  'address',
  'updated_at',
  'custom:groupId',
  'cognito:mfa_enabled',
  'cognito:username',
];

const COL_NAME = internalCsvHeaders.findIndex((col) => col === 'name');
const COL_EMAIL = internalCsvHeaders.findIndex((col) => col === 'email');
const COL_USER = internalCsvHeaders.findIndex((col) => col === 'cognito:username');

// Autogenerated
const COL_EMAIL_VERIFIED = internalCsvHeaders.findIndex(
  (col) => col === 'email_verified'
);
const COL_PHONE_VERIFIED = internalCsvHeaders.findIndex(
  (col) => col === 'phone_number_verified'
);
const COL_MFA_ENABLED = internalCsvHeaders.findIndex(
  (col) => col === 'cognito:mfa_enabled'
);

const internalBaseCsvRow = internalCsvHeaders.map(() => '');
internalBaseCsvRow[COL_EMAIL_VERIFIED] = 'TRUE';
internalBaseCsvRow[COL_PHONE_VERIFIED] = 'FALSE';
internalBaseCsvRow[COL_MFA_ENABLED] = 'FALSE';

export const createNewUserRow = (name: string, username: string, email: string) => {
  const newRow = [...internalBaseCsvRow];
  newRow[COL_NAME] = name;
  newRow[COL_USER] = username;
  newRow[COL_EMAIL] = email;
  return newRow;
};

export const generateUsername = (schId: string, classId: string, name: string) => {
  return `${schId}-${classId}-${name}`.replace(/[^a-zA-Z0-9-]+/, '');
};

export const processCsvFile = async (csvFile) => {
  const csvData = await new Promise<string[][]>((resolve, reject) => {
    Papa.parse(csvFile, {
      complete: (results) => resolve(results.data as string[][]),
      error: (error) => {
        console.log(error);
        reject(CsvReadError.INVALID_FILE);
      },
    });
  });

  const validCsvData = repairCsvArray(csvData);

  const studentsData = validCsvData.slice(1).map((row) => ({
    name: row[0],
    schoolId: row[1],
    class: row[2],
    username: generateUsername(row[1], row[2], row[0]),
  }));

  return studentsData;
};

const repairCsvArray = (csvArray: string[][]) => {
  const cleanedArray = removeEmptyRows(csvArray);
  console.log(cleanedArray);

  if (!checkHeaderIntegrity(cleanedArray[0])) {
    throw CsvReadError.INVALID_HEADER;
  }

  if (!checkRowIntegrity(cleanedArray)) {
    throw CsvReadError.INVALID_ROW;
  }

  return cleanedArray;
};

const removeEmptyRows = (csvArray: string[][]) => {
  return csvArray.filter((row) => {
    if (row.length === 0) return false;
    if (row.length === 1 && row[0] === '') return false;
    return true;
  });
};

const checkHeaderIntegrity = (header: string[]) => {
  return (
    JSON.stringify(header).toLowerCase() === JSON.stringify(csvHeaders).toLowerCase()
  );
};

const checkRowIntegrity = (csvArray: string[][]) => {
  for (let i = 1; i < csvArray.length; i++) {
    if (csvArray[i].length !== csvHeaders.length) {
      return false;
    }

    for (let item of csvArray[i]) {
      console.log(item);
      if (item.length === 0 || item.length > 64) {
        return false;
      }
    }
  }
  return true;
};

export const constructAwsUserImportJobCsv = (students: StudentEntry[]) => {
  const importJobArray = [internalCsvHeaders].concat(
    students.map((student) =>
      createNewUserRow(student.name, student.username, 'test@account')
    )
  );
  console.log(importJobArray);

  const importJobCsvString = Papa.unparse(importJobArray);
  return importJobCsvString;
  // const importJobCsvFile = new Blob([importJobCsvString], { type: 'text/csv' });
  // return importJobCsvFile;
};
